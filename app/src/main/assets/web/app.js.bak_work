(() => {
  const TASK_STORAGE_KEY = "flow_schedule_items_v1";
  const PROFILE_STORAGE_KEY = "taskx_profile_v1";
  const QUOTES_STORAGE_KEY = "taskx_learning_quotes_v1";
  const QUOTES_LAUNCHER_STORAGE_KEY = "taskx_quotes_launcher_v2";
  const BOT_SETTINGS_STORAGE_KEY = "taskx_bot_settings_v1";
  const BOT_MESSAGES_STORAGE_KEY = "taskx_bot_messages_v1";
  const BOT_HISTORY_STORAGE_KEY = "taskx_bot_history_v1";
  const BOT_MEMORY_STORAGE_KEY = "taskx_bot_memory_v1";
  const THEME_STORAGE_KEY = "taskx_theme_v1";
  const PASSWORD_FEATURE_ENABLED = false;

  const OLLAMA_DEFAULT_ENDPOINT = "http://10.0.2.2:11434/api/chat";
  const HUGGINGFACE_CHAT_ENDPOINT = "https://text.pollinations.ai/openai";
  const BOT_MAX_CONTEXT_MESSAGES = 12;
  const BOT_FIXED_FREE_API_KEY = 'taskx-free';
  const BOT_REQUEST_TIMEOUT_MS = 35000;

  const BREAKPOINTS = {
    medium: 700,
    expanded: 1100
  };

  const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const PHONE_PATTERN = /^[0-9+()\-\s]{7,20}$/;
  const QUOTE_SPLASH_DELAY_MS = 260;
  const QUOTES_LAUNCHER_EDGE_RESIZE_PX = 14;
  const QUOTES_LAUNCHER_MIN_SIZE = 72;
  const QUOTES_LAUNCHER_MAX_SIZE = 260;
  const TASK_LONG_PRESS_MS = 460;
  const TASK_LONG_PRESS_MOVE_PX = 10;
  const BOT_FAB_AUTO_HIDE_MS = 5600;
  const TASK_TAG_OPTIONS = {
    learning: "Learning",
    fitness: "Fitness",
    work: "Work",
    language: "Language",
    general: "General"
  };
  let quotesLauncherTimer = 0;

  const DEFAULT_SCHEDULE_ITEMS = [
    {
      id: "task-1",
      time: "08:00 - 09:30",
      title: "Morning Study Block",
      tag: "Learning",
      tagClass: "learning",
      completed: false
    },
    {
      id: "task-2",
      time: "10:00 - 11:00",
      title: "Gym",
      tag: "Fitness",
      tagClass: "fitness",
      completed: false
    },
    {
      id: "task-3",
      time: "14:30 - 16:00",
      title: "Deep Work: Python Project",
      tag: "Work",
      tagClass: "work",
      completed: false
    },
    {
      id: "task-4",
      time: "19:00 - 20:00",
      title: "Spanish Lesson",
      tag: "Language",
      tagClass: "language",
      completed: false
    }
  ];

  const DEFAULT_PROFILE = {
    fullName: "Raushan",
    email: "",
    phone: "",
    birthDate: "",
    city: "",
    address: "",
    bio: "",
    lockEnabled: false,
    passwordHash: ""
  };

  const DEFAULT_QUOTES_LAUNCHER = {
    x: 0,
    y: 0,
    size: 96,
    label: "Quote"
  };

  const DEFAULT_BOT_MEMORY = {
    interactions: 0,
    terms: {}
  };

  const DEFAULT_BOT_SETTINGS = {
    provider: "huggingface",
    model: "gpt-oss-20b",
    endpoint: HUGGINGFACE_CHAT_ENDPOINT,
    apiKey: BOT_FIXED_FREE_API_KEY,
    systemPrompt: "You are Pikachu. Keep responses concise, practical, and action-oriented for personal scheduling and learning."
  };

  const state = {
    size: "compact",
    resizeTicking: false,
    touchStartX: 0,
    touchStartY: 0,
    touchLastX: 0,
    touchLastY: 0,
    touchActive: false,
    currentView: "today",
    lastNonBotView: "today",
    scheduleItems: [],
    profile: { ...DEFAULT_PROFILE },
    quotes: [],
    quotesLauncher: { ...DEFAULT_QUOTES_LAUNCHER },
    quotesLauncherDrag: null,
    quotesLauncherIgnoreClick: false,
    quotesLauncherEdgeHover: false,
    quotesLauncherRenderFrame: 0,
    quotesLauncherRenderBounds: null,
    botSettings: { ...DEFAULT_BOT_SETTINGS },
    botMessages: [],
    botHistory: [],
    botMemory: { ...DEFAULT_BOT_MEMORY },
    botIsSending: false,
    botAbortController: null,
    botRequestToken: 0,
    theme: "dark",
    clockTimer: 0,
    todayCrudTaskId: "",
    taskLongPress: null,
    quoteLongPress: null,
    contextMenuTarget: null,
    confirmResolver: null,
    botFabAutoHideTimer: 0,
    botFabHidden: false
  };

  const dom = {
    appRoot: document.getElementById("appRoot"),
    themeToggleButton: document.getElementById("themeToggleButton"),
    themeToggleIcon: document.getElementById("themeToggleIcon"),
    drawerToggle: document.getElementById("drawerToggle"),
    drawerScrim: document.getElementById("drawerScrim"),
    profileScrim: document.getElementById("profileScrim"),
    quoteScrim: document.getElementById("quoteScrim"),
    taskScrim: document.getElementById("taskScrim"),
    confirmScrim: document.getElementById("confirmScrim"),
    contextMenuScrim: document.getElementById("contextMenuScrim"),
    botHistoryScrim: document.getElementById("botHistoryScrim"),

    navDrawer: document.getElementById("navDrawer"),
    profileSheet: document.getElementById("profileSheet"),
    quoteSheet: document.getElementById("quoteSheet"),
    taskSheet: document.getElementById("taskSheet"),

    drawerProfileButton: document.getElementById("drawerProfileButton"),
    drawerProfileAvatar: document.getElementById("drawerProfileAvatar"),
    drawerProfileName: document.getElementById("drawerProfileName"),
    drawerProfileMeta: document.getElementById("drawerProfileMeta"),

    profileCloseButton: document.getElementById("profileCloseButton"),
    profileForm: document.getElementById("profileForm"),
    profileName: document.getElementById("profileName"),
    profileEmail: document.getElementById("profileEmail"),
    profilePhone: document.getElementById("profilePhone"),
    profileBirthDate: document.getElementById("profileBirthDate"),
    profileCity: document.getElementById("profileCity"),
    profileAddress: document.getElementById("profileAddress"),
    profileBio: document.getElementById("profileBio"),
    profileLockEnabled: document.getElementById("profileLockEnabled"),
    profilePassword: document.getElementById("profilePassword"),
    profilePasswordConfirm: document.getElementById("profilePasswordConfirm"),
    profilePasswordLabel: document.querySelector('label[for="profilePassword"]'),
    profilePasswordConfirmLabel: document.querySelector('label[for="profilePasswordConfirm"]'),
    profileLockRow: document.querySelector(".profile-switch"),
    profileHint: document.querySelector(".profile-hint"),
    profileFeedback: document.getElementById("profileFeedback"),
    profileResetButton: document.getElementById("profileResetButton"),

    todayView: document.getElementById("todayView"),
    learningView: document.getElementById("learningView"),
    quotesView: document.getElementById("quotesView"),
    botView: document.getElementById("botView"),
    upcomingView: document.getElementById("upcomingView"),
    greetingText: document.getElementById("greetingText"),
    todayDateText: document.getElementById("todayDateText"),
    todayTimeText: document.getElementById("todayTimeText"),

    scheduleList: document.getElementById("scheduleList"),
    progressRing: document.getElementById("progressRing"),
    progressValue: document.getElementById("progressValue"),
    progressDetails: document.getElementById("progressDetails"),
    addTaskButton: document.getElementById("addTaskButton"),
    todayCrudHint: document.getElementById("todayCrudHint"),

    addQuoteButton: document.getElementById("addQuoteButton"),
    quotesLauncher: document.getElementById("quotesLauncher"),
    quotesLauncherTitle: document.getElementById("quotesLauncherTitle"),
    quotesEditButton: document.getElementById("quotesEditButton"),
    backToLearningButton: document.getElementById("backToLearningButton"),
    quoteList: document.getElementById("quoteList"),
    quoteCloseButton: document.getElementById("quoteCloseButton"),
    quoteSheetTitle: document.getElementById("quoteSheetTitle"),
    quoteForm: document.getElementById("quoteForm"),
    quoteEditingId: document.getElementById("quoteEditingId"),
    quoteText: document.getElementById("quoteText"),
    quoteAuthor: document.getElementById("quoteAuthor"),
    quoteDeleteButton: document.getElementById("quoteDeleteButton"),

    taskCloseButton: document.getElementById("taskCloseButton"),
    taskSheetTitle: document.getElementById("taskSheetTitle"),
    taskForm: document.getElementById("taskForm"),
    taskEditingId: document.getElementById("taskEditingId"),
    taskTitle: document.getElementById("taskTitle"),
    taskTime: document.getElementById("taskTime"),
    taskTag: document.getElementById("taskTag"),
    taskCompleted: document.getElementById("taskCompleted"),
    taskDeleteButton: document.getElementById("taskDeleteButton"),

    confirmSheet: document.getElementById("confirmSheet"),
    confirmTitle: document.getElementById("confirmTitle"),
    confirmMessage: document.getElementById("confirmMessage"),
    confirmCancelButton: document.getElementById("confirmCancelButton"),
    confirmAcceptButton: document.getElementById("confirmAcceptButton"),

    crudContextMenu: document.getElementById("crudContextMenu"),
    crudContextTitle: document.getElementById("crudContextTitle"),
    crudEditButton: document.getElementById("crudEditButton"),
    crudToggleButton: document.getElementById("crudToggleButton"),
    crudToggleText: document.getElementById("crudToggleText"),
    crudDeleteButton: document.getElementById("crudDeleteButton"),

    botFabButton: document.getElementById("botFabButton"),
    botRevealButton: document.getElementById("botRevealButton"),
    botBackButton: document.getElementById("botBackButton"),
    botHistoryButton: document.getElementById("botHistoryButton"),
    botHistorySheet: document.getElementById("botHistorySheet"),
    botHistoryCloseButton: document.getElementById("botHistoryCloseButton"),
    botHistoryList: document.getElementById("botHistoryList"),
    botClearButton: document.getElementById("botClearButton"),
    botSettingsForm: document.getElementById("botSettingsForm"),
    botProvider: document.getElementById("botProvider"),
    botModel: document.getElementById("botModel"),
    botEndpoint: document.getElementById("botEndpoint"),
    botApiKey: document.getElementById("botApiKey"),
    botProviderHint: document.getElementById("botProviderHint"),
    botSettingsFeedback: document.getElementById("botSettingsFeedback"),
    botResetSettingsButton: document.getElementById("botResetSettingsButton"),
    botMessageList: document.getElementById("botMessageList"),
    botComposerForm: document.getElementById("botComposerForm"),
    botPromptInput: document.getElementById("botPromptInput"),
    botSendButton: document.getElementById("botSendButton"),

    drawerItems: document.querySelectorAll("[data-drawer-item]"),
    navItems: document.querySelectorAll("[data-nav-item]")
  };

    function init() {
    state.scheduleItems = loadScheduleItems();
    state.profile = loadProfile();
    state.quotes = loadQuotes();
    state.quotesLauncher = loadQuotesLauncher();
    state.botSettings = loadBotSettings();
    state.botMessages = loadBotMessages();
    state.botHistory = loadBotHistory();
    state.botMemory = loadBotMemory();
    state.botMemory.interactions += 1;
    saveBotMemory();

    state.theme = loadThemePreference();
    applyTheme(state.theme, false);
    applyPerformanceMode();

    applyPasswordFeatureState();
    renderSchedule();
    renderProgress();
    applyProfileToUI();
    updateTodayHeaderRealtime();
    startRealtimeClock();
    renderQuotes();
    applyQuotesLauncherToUI();
    applyBotSettingsToUI();
    renderBotMessages();
    renderBotHistoryList();
    autoResizeBotPrompt();
    updateTodayCrudUI();

    attachEvents();
    applyAdaptiveLayout(true);
    setCurrentView("today");
    showBotFab(true);

    window.TaskXApp = Object.assign(window.TaskXApp || {}, {
      handleBack: () => handleAppBackAction()
    });
  }

      function attachEvents() {
    dom.themeToggleButton.addEventListener("click", onThemeToggleClick);

    dom.drawerToggle.addEventListener("click", toggleDrawer);
    dom.drawerScrim.addEventListener("click", closeDrawer);

    dom.drawerProfileButton.addEventListener("click", () => {
      openProfileSheet();
    });

    dom.profileCloseButton.addEventListener("click", closeProfileSheet);
    dom.profileScrim.addEventListener("click", closeProfileSheet);
    dom.profileForm.addEventListener("submit", onProfileSubmit);
    dom.profileResetButton.addEventListener("click", onProfileReset);

    dom.scheduleList.addEventListener("click", onScheduleListClick);
    dom.scheduleList.addEventListener("pointerdown", onSchedulePointerDown);
    dom.scheduleList.addEventListener("pointermove", onSchedulePointerMove);
    dom.scheduleList.addEventListener("pointerup", onSchedulePointerEnd);
    dom.scheduleList.addEventListener("pointercancel", onSchedulePointerEnd);
    dom.scheduleList.addEventListener("contextmenu", onScheduleContextMenu);
    dom.todayView.addEventListener("click", onTodayViewClick);
    dom.addTaskButton.addEventListener("click", () => {
      openTaskSheet();
    });
    dom.taskCloseButton.addEventListener("click", closeTaskSheet);
    dom.taskScrim.addEventListener("click", closeTaskSheet);
    dom.taskForm.addEventListener("submit", onTaskFormSubmit);
    dom.taskDeleteButton.addEventListener("click", onDeleteEditingTask);

    dom.confirmCancelButton.addEventListener("click", () => resolveConfirmDialog(false));
    dom.confirmAcceptButton.addEventListener("click", () => resolveConfirmDialog(true));
    dom.confirmScrim.addEventListener("click", () => resolveConfirmDialog(false));

    dom.contextMenuScrim.addEventListener("click", closeCrudContextMenu);
    dom.crudEditButton.addEventListener("click", () => onCrudContextAction("edit"));
    dom.crudToggleButton.addEventListener("click", () => onCrudContextAction("toggle"));
    dom.crudDeleteButton.addEventListener("click", () => onCrudContextAction("delete"));

    dom.addQuoteButton.addEventListener("click", () => {
      openQuoteSheet();
    });
    dom.quotesLauncher.addEventListener("click", onQuotesLauncherClick);
    dom.quotesLauncher.addEventListener("keydown", onQuotesLauncherKeyDown);
    dom.quotesLauncher.addEventListener("pointerdown", onQuotesLauncherPointerDown);
    dom.quotesLauncher.addEventListener("mousemove", onQuotesLauncherHoverMove);
    dom.quotesLauncher.addEventListener("mouseleave", onQuotesLauncherHoverLeave);
    dom.quotesEditButton.addEventListener("click", onQuotesLauncherEditClick);
    dom.backToLearningButton.addEventListener("click", () => setCurrentView("learning"));
    dom.quoteCloseButton.addEventListener("click", closeQuoteSheet);
    dom.quoteScrim.addEventListener("click", closeQuoteSheet);
    dom.quoteForm.addEventListener("submit", onQuoteFormSubmit);
    dom.quoteDeleteButton.addEventListener("click", onDeleteEditingQuote);
    dom.quoteList.addEventListener("click", onQuoteListClick);
    dom.quoteList.addEventListener("pointerdown", onQuotePointerDown);
    dom.quoteList.addEventListener("pointermove", onQuotePointerMove);
    dom.quoteList.addEventListener("pointerup", onQuotePointerEnd);
    dom.quoteList.addEventListener("pointercancel", onQuotePointerEnd);
    dom.quoteList.addEventListener("contextmenu", onQuoteContextMenu);

    dom.botFabButton.addEventListener("click", openBotDisplay);
    dom.botRevealButton.addEventListener("click", onBotRevealButtonClick);
    dom.botBackButton.addEventListener("click", closeBotDisplay);
    dom.botHistoryButton.addEventListener("click", openBotHistorySheet);
    dom.botHistoryCloseButton.addEventListener("click", closeBotHistorySheet);
    dom.botHistoryScrim.addEventListener("click", closeBotHistorySheet);
    dom.botHistoryList.addEventListener("click", onBotHistoryListClick);
    dom.botSettingsForm.addEventListener("submit", onBotSettingsSubmit);
    dom.botResetSettingsButton.addEventListener("click", onBotResetSettings);
    dom.botProvider.addEventListener("change", onBotProviderChange);
    dom.botClearButton.addEventListener("click", onBotClearChat);
    dom.botComposerForm.addEventListener("submit", onBotComposerSubmit);
    dom.botPromptInput.addEventListener("keydown", onBotPromptKeyDown);
    dom.botPromptInput.addEventListener("input", autoResizeBotPrompt);

    for (const item of dom.drawerItems) {
      item.addEventListener("click", () => {
        const view = item.dataset.view;
        if (view) {
          setCurrentView(view);
        }
        if (state.size !== "expanded") {
          closeDrawer();
        }
      });
    }

    for (const item of dom.navItems) {
      item.addEventListener("click", () => {
        const view = item.dataset.view;
        if (view) {
          setCurrentView(view);
        }
      });
    }

    dom.appRoot.addEventListener("pointerdown", onUserInteraction, { passive: true });
    dom.appRoot.addEventListener("wheel", onUserInteraction, { passive: true });
    dom.todayView.addEventListener("scroll", onUserInteraction, { passive: true });
    dom.learningView.addEventListener("scroll", onUserInteraction, { passive: true });
    dom.quotesView.addEventListener("scroll", onUserInteraction, { passive: true });
    dom.upcomingView.addEventListener("scroll", onUserInteraction, { passive: true });

    dom.appRoot.addEventListener("touchstart", onTouchStart, { passive: true });
    dom.appRoot.addEventListener("touchmove", onTouchMove, { passive: true });
    dom.appRoot.addEventListener("touchend", onTouchEnd, { passive: true });
    dom.appRoot.addEventListener("touchcancel", resetTouchState);

    document.addEventListener("visibilitychange", onVisibilityChange);
    window.addEventListener("resize", onWindowResize);
    document.addEventListener("keydown", (event) => {
      if (event.key !== "Escape") {
        return;
      }
      if (handleAppBackAction()) {
        event.preventDefault();
      }
    });
  }

    function handleAppBackAction() {
    if (dom.appRoot.classList.contains("context-menu-open")) {
      closeCrudContextMenu();
      return true;
    }

    if (dom.appRoot.classList.contains("bot-history-open")) {
      closeBotHistorySheet();
      return true;
    }

    if (dom.appRoot.classList.contains("confirm-open")) {
      resolveConfirmDialog(false);
      return true;
    }

    if (dom.appRoot.classList.contains("profile-open")) {
      closeProfileSheet();
      return true;
    }

    if (dom.appRoot.classList.contains("quote-open")) {
      closeQuoteSheet();
      return true;
    }

    if (dom.appRoot.classList.contains("task-open")) {
      closeTaskSheet();
      return true;
    }

    if (state.currentView === "quotes") {
      setCurrentView("learning");
      return true;
    }

    if (state.currentView === "bot") {
      closeBotDisplay();
      return true;
    }

    if (state.size !== "expanded" && dom.appRoot.classList.contains("drawer-open")) {
      closeDrawer();
      return true;
    }

    return false;
  }

    function setCurrentView(view) {
    if (view === "quotes" && state.currentView !== "learning" && state.currentView !== "quotes") {
      return;
    }

    if (view !== "bot") {
      state.lastNonBotView = view === "quotes" ? "learning" : view;
    }

    state.currentView = view;

    dom.todayView.hidden = view !== "today";
    dom.learningView.hidden = view !== "learning";
    dom.quotesView.hidden = view !== "quotes";
    dom.botView.hidden = view !== "bot";
    dom.upcomingView.hidden = view !== "upcoming";

    const isBotView = view === "bot";
    dom.botFabButton.hidden = isBotView;
    dom.botRevealButton.hidden = isBotView;
    dom.appRoot.classList.toggle("bot-open", isBotView);

    closeCrudContextMenu();
    cancelScheduleLongPress();
    cancelQuoteLongPress();

    if (isBotView) {
      clearBotFabAutoHideTimer();
      state.botFabHidden = false;
      dom.appRoot.classList.remove("bot-fab-hidden");
      closeDrawer();
      closeProfileSheet();
      closeQuoteSheet();
      closeTaskSheet();
      resolveConfirmDialog(false);
      closeBotHistorySheet();
    } else {
      showBotFab(true);
      closeBotHistorySheet();
    }

    if (view !== "learning") {
      window.clearTimeout(quotesLauncherTimer);
      quotesLauncherTimer = 0;
      dom.quotesLauncher.classList.remove("splashing");
      dom.quotesLauncher.classList.remove("edge-resize");
      state.quotesLauncherIgnoreClick = false;
      cancelQuotesLauncherInteraction();
      cancelQuotesLauncherRender();
    } else {
      scheduleQuotesLauncherRender();
    }

    if (view !== "quotes") {
      closeQuoteSheet();
    }

    if (view !== "today") {
      closeTaskSheet();
    } else {
      updateTodayCrudUI();
    }

    if (view !== "bot") {
      onBotStopRequest(true);
      clearBotSettingsFeedback();
    }

    const baseView = view === "bot" ? (state.lastNonBotView || "today") : view;
    const selectedDrawerView = baseView === "quotes" ? "learning" : baseView;
    const selectedBottomView = baseView === "quotes" ? "learning" : baseView;

    for (const item of dom.drawerItems) {
      item.classList.toggle("selected", item.dataset.view === selectedDrawerView);
    }

    for (const item of dom.navItems) {
      item.classList.toggle("selected", item.dataset.view === selectedBottomView);
    }
  }

    function renderSchedule() {
    if (!state.scheduleItems.length) {
      dom.scheduleList.innerHTML = `
        <li class="schedule-card schedule-empty" style="--index:0">
          <p class="card-title">No tasks yet.</p>
          <p class="card-time">Tap Add to create your first task.</p>
        </li>
      `;
      updateTodayCrudUI();
      return;
    }

    if (state.todayCrudTaskId && !state.scheduleItems.some((item) => item.id === state.todayCrudTaskId)) {
      state.todayCrudTaskId = "";
    }

    dom.scheduleList.innerHTML = state.scheduleItems
      .map((item, index) => {
        const isActive = item.id === state.todayCrudTaskId;
        return `
          <li class="schedule-card ${item.completed ? "is-complete" : ""} ${isActive ? "crud-active" : ""}" data-task-id="${escapeHtml(item.id)}" style="--index:${index}">
            <div class="card-top">
              <div>
                <p class="card-time">${escapeHtml(item.time)}</p>
                <h3 class="card-title">${escapeHtml(item.title)}</h3>
              </div>
            </div>
            <span class="card-tag ${escapeHtml(item.tagClass)}">${escapeHtml(item.tag)}</span>
          </li>
        `;
      })
      .join("");

    updateTodayCrudUI();
  }

  function renderProgress() {
    const total = state.scheduleItems.length;
    const completed = state.scheduleItems.filter((item) => item.completed).length;
    const active = Math.max(total - completed, 0);
    const percent = total ? Math.round((completed / total) * 100) : 0;

    dom.progressRing.style.setProperty("--progress", String(percent));
    dom.progressValue.textContent = `${percent}%`;
    dom.progressDetails.textContent = `${total} session${total === 1 ? "" : "s"} planned, ${completed} completed, ${active} active.`;
  }

  function openTaskSheet(taskId = "") {
    if (state.currentView !== "today") {
      return;
    }

    closeDrawer();
    closeProfileSheet();
    closeQuoteSheet();

    const task = taskId ? state.scheduleItems.find((item) => item.id === taskId) : null;

    if (task) {
      dom.taskEditingId.value = task.id;
      dom.taskTitle.value = task.title;
      dom.taskTime.value = task.time;
      dom.taskTag.value = normalizeTagClass(task.tagClass);
      dom.taskCompleted.checked = Boolean(task.completed);
      dom.taskSheetTitle.textContent = "Edit Task";
      dom.taskDeleteButton.hidden = false;
    } else {
      dom.taskEditingId.value = "";
      dom.taskTitle.value = "";
      dom.taskTime.value = "";
      dom.taskTag.value = "learning";
      dom.taskCompleted.checked = false;
      dom.taskSheetTitle.textContent = "Add Task";
      dom.taskDeleteButton.hidden = true;
    }

    dom.appRoot.classList.add("task-open");
    window.requestAnimationFrame(() => {
      dom.taskTitle.focus();
    });
  }

  function closeTaskSheet() {
    dom.appRoot.classList.remove("task-open");
  }

      function onTaskFormSubmit(event) {
    event.preventDefault();

    const title = sanitizeText(dom.taskTitle.value);
    const time = sanitizeText(dom.taskTime.value);
    const tagClass = normalizeTagClass(dom.taskTag.value);
    const completed = Boolean(dom.taskCompleted.checked);

    if (!title) {
      window.alert("Task title is required.");
      return;
    }

    if (!time) {
      window.alert("Task time is required.");
      return;
    }

    const editingId = dom.taskEditingId.value;
    const tag = getTaskTagLabel(tagClass);

    if (editingId) {
      state.scheduleItems = state.scheduleItems.map((item) => {
        if (item.id !== editingId) {
          return item;
        }
        return {
          ...item,
          time,
          title,
          tag,
          tagClass,
          completed
        };
      });
      state.todayCrudTaskId = editingId;
    } else {
      const nextId = "task-" + Date.now() + "-" + Math.floor(Math.random() * 100000);
      state.scheduleItems.push({
        id: nextId,
        time,
        title,
        tag,
        tagClass,
        completed
      });
      state.todayCrudTaskId = nextId;
    }

    saveScheduleItems();
    renderSchedule();
    renderProgress();
    closeTaskSheet();
  }

  async function onDeleteEditingTask() {
    const editingId = dom.taskEditingId.value;
    if (!editingId) {
      return;
    }

    const deleted = await removeTask(editingId);
    if (deleted) {
      closeTaskSheet();
    }
  }

  async function removeTask(id, skipConfirm = false) {
    if (!id) {
      return false;
    }

    const task = state.scheduleItems.find((item) => item.id === id);
    if (!task) {
      return false;
    }

    if (!skipConfirm) {
      const ok = await showConfirmDialog({
        title: "Delete task?",
        message: `"${task.title}" will vanish from your schedule.`,
        confirmLabel: "Delete"
      });
      if (!ok) {
        return false;
      }
    }

    const taskCard = findTaskCardById(id);
    await runDeleteVanishAnimation(taskCard);

    state.scheduleItems = state.scheduleItems.filter((item) => item.id !== id);
    if (state.todayCrudTaskId === id) {
      state.todayCrudTaskId = "";
    }

    saveScheduleItems();
    renderSchedule();
    renderProgress();
    closeCrudContextMenu();
    return true;
  }

  function onScheduleListClick(event) {
    const card = event.target.closest(".schedule-card[data-task-id]");
    if (!card) {
      return;
    }

    state.todayCrudTaskId = card.dataset.taskId || "";
    renderSchedule();
  }

  function updateTodayCrudUI() {
    const hasTasks = state.scheduleItems.length > 0;

    dom.addTaskButton.hidden = false;
    dom.appRoot.classList.toggle("today-crud-active", Boolean(state.todayCrudTaskId));

    if (!dom.todayCrudHint) {
      return;
    }

    if (!hasTasks) {
      dom.todayCrudHint.textContent = "No tasks yet. Tap Add to create your first task.";
      return;
    }

    dom.todayCrudHint.textContent = "Long press any task to open Edit / Complete / Delete.";
  }

  function clearTodayCrudSelection(silent = false) {
    if (!state.todayCrudTaskId) {
      return;
    }
    state.todayCrudTaskId = "";
    renderSchedule();
    if (!silent) {
      onUserInteraction();
    }
  }

  function activateTodayCrudForTask(taskId) {
    if (!taskId || state.currentView !== "today") {
      return;
    }

    state.todayCrudTaskId = taskId;
    renderSchedule();

    if (typeof navigator !== "undefined" && typeof navigator.vibrate === "function") {
      navigator.vibrate(14);
    }
  }

  function onSchedulePointerDown(event) {
    if (state.currentView !== "today") {
      return;
    }

    if (!isPrimaryPointer(event)) {
      return;
    }

    const card = event.target.closest(".schedule-card[data-task-id]");
    if (!card) {
      return;
    }

    closeCrudContextMenu();
    cancelScheduleLongPress();

    const taskId = card.dataset.taskId;
    const pressX = event.clientX;
    const pressY = event.clientY;

    const timer = window.setTimeout(() => {
      state.taskLongPress = null;
      card.classList.remove("pressing");
      activateTodayCrudForTask(taskId);
      openCrudContextMenu({
        type: "task",
        id: taskId,
        x: pressX,
        y: pressY
      });
    }, TASK_LONG_PRESS_MS);

    state.taskLongPress = {
      pointerId: event.pointerId,
      startX: event.clientX,
      startY: event.clientY,
      taskId,
      card,
      timer
    };

    card.classList.add("pressing");
  }

  function onSchedulePointerMove(event) {
    const hold = state.taskLongPress;
    if (!hold || hold.pointerId !== event.pointerId) {
      return;
    }

    const deltaX = Math.abs(event.clientX - hold.startX);
    const deltaY = Math.abs(event.clientY - hold.startY);

    if (deltaX > TASK_LONG_PRESS_MOVE_PX || deltaY > TASK_LONG_PRESS_MOVE_PX) {
      cancelScheduleLongPress();
    }
  }

  function onSchedulePointerEnd(event) {
    const hold = state.taskLongPress;
    if (!hold || hold.pointerId !== event.pointerId) {
      return;
    }

    cancelScheduleLongPress();
  }

  function cancelScheduleLongPress() {
    const hold = state.taskLongPress;
    if (!hold) {
      return;
    }

    window.clearTimeout(hold.timer);
    hold.card?.classList.remove("pressing");
    state.taskLongPress = null;
  }

  function onScheduleContextMenu(event) {
    const card = event.target.closest(".schedule-card[data-task-id]");
    if (!card) {
      return;
    }
    event.preventDefault();
  }

  function onTodayViewClick(event) {
    const insideCard = event.target.closest(".schedule-card[data-task-id]");
    const insideContextMenu = event.target.closest(".crud-context-menu");
    if (insideCard || insideContextMenu) {
      return;
    }

    closeCrudContextMenu();
    clearTodayCrudSelection(true);
  }

  function onQuotePointerDown(event) {
    if (!canAccessQuotes() || !isPrimaryPointer(event)) {
      return;
    }

    const item = event.target.closest(".quote-item[data-quote-id]");
    if (!item) {
      return;
    }

    closeCrudContextMenu();
    cancelQuoteLongPress();

    const quoteId = item.dataset.quoteId;
    const pressX = event.clientX;
    const pressY = event.clientY;

    const timer = window.setTimeout(() => {
      state.quoteLongPress = null;
      item.classList.remove("pressing");
      openCrudContextMenu({
        type: "quote",
        id: quoteId,
        x: pressX,
        y: pressY
      });
      if (typeof navigator !== "undefined" && typeof navigator.vibrate === "function") {
        navigator.vibrate(14);
      }
    }, TASK_LONG_PRESS_MS);

    state.quoteLongPress = {
      pointerId: event.pointerId,
      startX: event.clientX,
      startY: event.clientY,
      quoteId,
      item,
      timer
    };

    item.classList.add("pressing");
  }

  function onQuotePointerMove(event) {
    const hold = state.quoteLongPress;
    if (!hold || hold.pointerId !== event.pointerId) {
      return;
    }

    const deltaX = Math.abs(event.clientX - hold.startX);
    const deltaY = Math.abs(event.clientY - hold.startY);

    if (deltaX > TASK_LONG_PRESS_MOVE_PX || deltaY > TASK_LONG_PRESS_MOVE_PX) {
      cancelQuoteLongPress();
    }
  }

  function onQuotePointerEnd(event) {
    const hold = state.quoteLongPress;
    if (!hold || hold.pointerId !== event.pointerId) {
      return;
    }

    cancelQuoteLongPress();
  }

  function cancelQuoteLongPress() {
    const hold = state.quoteLongPress;
    if (!hold) {
      return;
    }

    window.clearTimeout(hold.timer);
    hold.item?.classList.remove("pressing");
    state.quoteLongPress = null;
  }

  function onQuoteContextMenu(event) {
    const item = event.target.closest(".quote-item[data-quote-id]");
    if (!item) {
      return;
    }
    event.preventDefault();
  }

  function findTaskCardById(id) {
    const cards = dom.scheduleList.querySelectorAll(".schedule-card[data-task-id]");
    for (const card of cards) {
      if (card.dataset.taskId === id) {
        return card;
      }
    }
    return null;
  }

    function renderQuotes() {
    if (!state.quotes.length) {
      dom.quoteList.innerHTML = `
        <li class="quote-empty">
          <p>No quotes yet. Tap + to add your first quote.</p>
        </li>
      `;
      return;
    }

    const sorted = [...state.quotes].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    dom.quoteList.innerHTML = sorted
      .map((quote, index) => {
        const author = quote.author ? `- ${escapeHtml(quote.author)}` : "Unknown";
        const created = formatDate(quote.createdAt);

        return `
          <li class="quote-item" data-quote-id="${escapeHtml(quote.id)}" style="--quote-index:${index}">
            <p class="quote-text">"${escapeHtml(quote.text)}"</p>
            <p class="quote-meta">${author} | ${created}</p>
          </li>
        `;
      })
      .join("");
  }

  function canAccessQuotes() {
    return state.currentView === "quotes" && !dom.quotesView.hidden;
  }

  function openQuotesDisplay() {
    if (state.currentView !== "learning") {
      return;
    }
    setCurrentView("quotes");
    window.requestAnimationFrame(() => {
      dom.quoteList.scrollTop = 0;
    });
  }

      function openBotDisplay() {
    if (state.currentView !== "bot") {
      state.lastNonBotView = state.currentView === "quotes" ? "learning" : state.currentView;
    }

    clearBotFabAutoHideTimer();
    state.botFabHidden = false;
    dom.appRoot.classList.remove("bot-fab-hidden");

    startNewBotChatSession();
    closeBotHistorySheet();

    setCurrentView("bot");
    window.requestAnimationFrame(() => {
      dom.botPromptInput.focus();
    });
  }

  function closeBotDisplay() {
    const fallbackView = state.lastNonBotView || "today";
    setCurrentView(fallbackView);
    showBotFab(true);
  }

  function onQuotesLauncherClick(event) {
    if (state.currentView !== "learning") {
      return;
    }

    if (state.quotesLauncherIgnoreClick) {
      state.quotesLauncherIgnoreClick = false;
      event.preventDefault();
      return;
    }

    playQuotesLauncherSplashAndOpen();
  }

  function onQuotesLauncherKeyDown(event) {
    if (state.currentView !== "learning") {
      return;
    }

    if (event.target !== dom.quotesLauncher) {
      return;
    }

    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      playQuotesLauncherSplashAndOpen();
    }
  }

  function playQuotesLauncherSplashAndOpen() {
    window.clearTimeout(quotesLauncherTimer);
    quotesLauncherTimer = 0;

    dom.quotesLauncher.classList.remove("splashing");
    void dom.quotesLauncher.offsetWidth;
    dom.quotesLauncher.classList.add("splashing");

    quotesLauncherTimer = window.setTimeout(() => {
      dom.quotesLauncher.classList.remove("splashing");
      quotesLauncherTimer = 0;
      openQuotesDisplay();
    }, QUOTE_SPLASH_DELAY_MS);
  }

  function onQuotesLauncherEditClick(event) {
    event.preventDefault();
    event.stopPropagation();

    if (state.currentView !== "learning") {
      return;
    }

    const currentLabel = state.quotesLauncher.label;
    const nextLabel = sanitizeText(window.prompt("Edit quote card label", currentLabel));
    if (!nextLabel) {
      return;
    }

    state.quotesLauncher.label = nextLabel.slice(0, 20);
    applyQuotesLauncherToUI();
    saveQuotesLauncher();
  }

  function onQuotesLauncherPointerDown(event) {
    if (state.currentView !== "learning") {
      return;
    }

    if (!isPrimaryPointer(event)) {
      return;
    }

    if (event.target.closest("#quotesEditButton")) {
      return;
    }

    const resizeEdge = getQuotesLauncherResizeEdge(event);
    if (resizeEdge) {
      startQuotesLauncherInteraction(event, "resize", resizeEdge);
      return;
    }

    startQuotesLauncherInteraction(event, "drag", null);
  }

  function onQuotesLauncherHoverMove(event) {
    if (state.currentView !== "learning" || state.quotesLauncherDrag) {
      return;
    }
    const resizeEdge = getQuotesLauncherResizeEdge(event);
    const hasResizeEdge = Boolean(resizeEdge);
    if (state.quotesLauncherEdgeHover === hasResizeEdge) {
      return;
    }
    state.quotesLauncherEdgeHover = hasResizeEdge;
    dom.quotesLauncher.classList.toggle("edge-resize", hasResizeEdge);
  }

  function onQuotesLauncherHoverLeave() {
    if (state.quotesLauncherDrag) {
      return;
    }
    if (!state.quotesLauncherEdgeHover) {
      return;
    }
    state.quotesLauncherEdgeHover = false;
    dom.quotesLauncher.classList.remove("edge-resize");
  }

  function startQuotesLauncherInteraction(event, mode, resizeEdge = null) {
    const { width, height } = getLearningBounds();
    if (!width || !height) {
      return;
    }

    event.preventDefault();
    window.clearTimeout(quotesLauncherTimer);
    quotesLauncherTimer = 0;
    dom.quotesLauncher.classList.remove("splashing");

    state.quotesLauncherDrag = {
      pointerId: event.pointerId,
      mode,
      edge: resizeEdge,
      bounds: { width, height },
      startX: event.clientX,
      startY: event.clientY,
      originX: state.quotesLauncher.x,
      originY: state.quotesLauncher.y,
      originSize: state.quotesLauncher.size,
      moved: false
    };

    state.quotesLauncherEdgeHover = false;
    dom.quotesLauncher.classList.remove("edge-resize");
    dom.quotesLauncher.classList.toggle("dragging", mode === "drag");
    dom.quotesLauncher.classList.toggle("resizing", mode === "resize");
    window.addEventListener("pointermove", onQuotesLauncherPointerMove);
    window.addEventListener("pointerup", onQuotesLauncherPointerUp);
    window.addEventListener("pointercancel", onQuotesLauncherPointerUp);
  }

  function onQuotesLauncherPointerMove(event) {
    const drag = state.quotesLauncherDrag;
    if (!drag || drag.pointerId !== event.pointerId) {
      return;
    }

    event.preventDefault();

    const deltaX = event.clientX - drag.startX;
    const deltaY = event.clientY - drag.startY;
    const { width, height } = drag.bounds || getLearningBounds();
    if (!width || !height) {
      return;
    }

    if (drag.mode === "drag") {
      const maxX = Math.max(0, width - state.quotesLauncher.size);
      const maxY = Math.max(0, height - state.quotesLauncher.size);
      state.quotesLauncher.x = clampNumber(drag.originX + deltaX, 0, maxX);
      state.quotesLauncher.y = clampNumber(drag.originY + deltaY, 0, maxY);
      if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
        drag.moved = true;
      }
      scheduleQuotesLauncherRender(drag.bounds);
      return;
    }

    const resizeDeltaCandidates = [];
    if (drag.edge?.right) {
      resizeDeltaCandidates.push(deltaX);
    }
    if (drag.edge?.left) {
      resizeDeltaCandidates.push(-deltaX);
    }
    if (drag.edge?.bottom) {
      resizeDeltaCandidates.push(deltaY);
    }
    if (drag.edge?.top) {
      resizeDeltaCandidates.push(-deltaY);
    }
    const deltaSize = resizeDeltaCandidates.length ? Math.max(...resizeDeltaCandidates) : 0;

    const maxSize = getQuotesLauncherMaxSizeForResize(width, height, drag);
    const nextSize = clampNumber(drag.originSize + deltaSize, QUOTES_LAUNCHER_MIN_SIZE, maxSize);

    let nextX = drag.originX;
    let nextY = drag.originY;
    if (drag.edge?.left) {
      nextX = drag.originX + (drag.originSize - nextSize);
    }
    if (drag.edge?.top) {
      nextY = drag.originY + (drag.originSize - nextSize);
    }

    state.quotesLauncher.size = nextSize;
    const maxX = Math.max(0, width - nextSize);
    const maxY = Math.max(0, height - nextSize);
    state.quotesLauncher.x = clampNumber(nextX, 0, maxX);
    state.quotesLauncher.y = clampNumber(nextY, 0, maxY);
    if (Math.abs(deltaSize) > 2) {
      drag.moved = true;
    }
    scheduleQuotesLauncherRender(drag.bounds);
  }

  function onQuotesLauncherPointerUp(event) {
    const drag = state.quotesLauncherDrag;
    if (!drag || drag.pointerId !== event.pointerId) {
      return;
    }

    const moved = drag.moved;
    const bounds = drag.bounds || null;
    cancelQuotesLauncherInteraction();
    cancelQuotesLauncherRender();
    applyQuotesLauncherToUI(bounds);
    saveQuotesLauncher();

    if (moved || drag.mode === "resize") {
      state.quotesLauncherIgnoreClick = true;
    }
  }

  function cancelQuotesLauncherInteraction() {
    window.removeEventListener("pointermove", onQuotesLauncherPointerMove);
    window.removeEventListener("pointerup", onQuotesLauncherPointerUp);
    window.removeEventListener("pointercancel", onQuotesLauncherPointerUp);
    state.quotesLauncherDrag = null;
    state.quotesLauncherEdgeHover = false;
    dom.quotesLauncher.classList.remove("dragging", "resizing", "edge-resize");
  }

  function applyQuotesLauncherToUI(boundsOverride = null) {
    const { width, height } = boundsOverride || getLearningBounds();
    const maxSize = getQuotesLauncherMaxSize(width, height);

    state.quotesLauncher.size = clampNumber(state.quotesLauncher.size, QUOTES_LAUNCHER_MIN_SIZE, maxSize);
    state.quotesLauncher.label = sanitizeText(state.quotesLauncher.label).slice(0, 20) || DEFAULT_QUOTES_LAUNCHER.label;

    if (width && height) {
      state.quotesLauncher.x = clampNumber(state.quotesLauncher.x, 0, Math.max(0, width - state.quotesLauncher.size));
      state.quotesLauncher.y = clampNumber(state.quotesLauncher.y, 0, Math.max(0, height - state.quotesLauncher.size));
    } else {
      state.quotesLauncher.x = Math.max(0, state.quotesLauncher.x);
      state.quotesLauncher.y = Math.max(0, state.quotesLauncher.y);
    }

    dom.quotesLauncher.style.left = `${state.quotesLauncher.x}px`;
    dom.quotesLauncher.style.top = `${state.quotesLauncher.y}px`;
    dom.quotesLauncher.style.setProperty("--quote-card-size", `${state.quotesLauncher.size}px`);
    const fontSizePx = clampNumber(Math.round(state.quotesLauncher.size * 0.26), 14, 48);
    dom.quotesLauncher.style.setProperty("--quote-card-font-size", `${fontSizePx}px`);
    dom.quotesLauncherTitle.textContent = state.quotesLauncher.label;
  }

  function scheduleQuotesLauncherRender(boundsOverride = null) {
    state.quotesLauncherRenderBounds = boundsOverride;
    if (state.quotesLauncherRenderFrame) {
      return;
    }
    state.quotesLauncherRenderFrame = window.requestAnimationFrame(() => {
      state.quotesLauncherRenderFrame = 0;
      const bounds = state.quotesLauncherRenderBounds;
      state.quotesLauncherRenderBounds = null;
      applyQuotesLauncherToUI(bounds);
    });
  }

  function cancelQuotesLauncherRender() {
    if (state.quotesLauncherRenderFrame) {
      window.cancelAnimationFrame(state.quotesLauncherRenderFrame);
      state.quotesLauncherRenderFrame = 0;
    }
    state.quotesLauncherRenderBounds = null;
  }

  function getLearningBounds() {
    return {
      width: dom.learningView.clientWidth,
      height: dom.learningView.clientHeight
    };
  }

  function getQuotesLauncherResizeEdge(event) {
    const rect = dom.quotesLauncher.getBoundingClientRect();
    const threshold = QUOTES_LAUNCHER_EDGE_RESIZE_PX;

    const nearLeft = event.clientX - rect.left <= threshold;
    const nearRight = rect.right - event.clientX <= threshold;
    const nearTop = event.clientY - rect.top <= threshold;
    const nearBottom = rect.bottom - event.clientY <= threshold;

    if (!nearLeft && !nearRight && !nearTop && !nearBottom) {
      return null;
    }

    return {
      left: nearLeft,
      right: nearRight,
      top: nearTop,
      bottom: nearBottom
    };
  }

  function getQuotesLauncherMaxSizeForResize(width, height, drag) {
    const edge = drag.edge || {};
    const maxByX = edge.left ? drag.originX + drag.originSize : width - drag.originX;
    const maxByY = edge.top ? drag.originY + drag.originSize : height - drag.originY;
    return Math.max(QUOTES_LAUNCHER_MIN_SIZE, Math.min(QUOTES_LAUNCHER_MAX_SIZE, maxByX, maxByY));
  }

  function getQuotesLauncherMaxSize(width, height) {
    if (!width || !height) {
      return QUOTES_LAUNCHER_MAX_SIZE;
    }
    return Math.max(QUOTES_LAUNCHER_MIN_SIZE, Math.min(QUOTES_LAUNCHER_MAX_SIZE, Math.min(width, height) - 8));
  }

    async   function onQuoteListClick(event) {
    if (!canAccessQuotes()) {
      return;
    }

    const item = event.target.closest(".quote-item[data-quote-id]");
    if (!item) {
      return;
    }

    closeCrudContextMenu();
  }

  function openQuoteSheet(quoteId = "") {
    if (!canAccessQuotes()) {
      return;
    }

    closeProfileSheet();
    closeDrawer();

    const quote = quoteId ? state.quotes.find((item) => item.id === quoteId) : null;

    if (quote) {
      dom.quoteEditingId.value = quote.id;
      dom.quoteText.value = quote.text;
      dom.quoteAuthor.value = quote.author || "";
      dom.quoteSheetTitle.textContent = "Edit Quote";
      dom.quoteDeleteButton.hidden = false;
    } else {
      dom.quoteEditingId.value = "";
      dom.quoteText.value = "";
      dom.quoteAuthor.value = "";
      dom.quoteSheetTitle.textContent = "Add Quote";
      dom.quoteDeleteButton.hidden = true;
    }

    dom.appRoot.classList.add("quote-open");
    window.requestAnimationFrame(() => {
      dom.quoteText.focus();
    });
  }

  function closeQuoteSheet() {
    dom.appRoot.classList.remove("quote-open");
  }

  function onQuoteFormSubmit(event) {
    event.preventDefault();

    const text = sanitizeText(dom.quoteText.value);
    const author = sanitizeText(dom.quoteAuthor.value);

    if (!text) {
      window.alert("Quote text is required.");
      return;
    }

    const editingId = dom.quoteEditingId.value;

    if (editingId) {
      state.quotes = state.quotes.map((quote) => {
        if (quote.id !== editingId) {
          return quote;
        }
        return {
          ...quote,
          text,
          author,
          updatedAt: new Date().toISOString()
        };
      });
      saveQuotes();
      renderQuotes();
      closeQuoteSheet();
      return;
    }

    state.quotes.push({
      id: `quote-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      text,
      author,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    saveQuotes();
    renderQuotes();
    closeQuoteSheet();
  }

  async function onDeleteEditingQuote() {
    const editingId = dom.quoteEditingId.value;
    if (!editingId) {
      return;
    }

    const deleted = await removeQuote(editingId);
    if (deleted) {
      closeQuoteSheet();
    }
  }

  async function removeQuote(id, skipConfirm = false) {
    if (!id) {
      return false;
    }

    const quote = state.quotes.find((item) => item.id === id);
    if (!quote) {
      return false;
    }

    if (!skipConfirm) {
      const ok = await showConfirmDialog({
        title: "Delete quote?",
        message: `"${quote.text.slice(0, 56)}${quote.text.length > 56 ? "..." : ""}" will be removed.`,
        confirmLabel: "Delete"
      });
      if (!ok) {
        return false;
      }
    }

    const quoteItem = findQuoteCardById(id);
    await runDeleteVanishAnimation(quoteItem);

    state.quotes = state.quotes.filter((quoteItemState) => quoteItemState.id !== id);
    saveQuotes();
    renderQuotes();
    return true;
  }
  function openCrudContextMenu(target) {
    if (!target || !target.type || !target.id) {
      return;
    }

    state.contextMenuTarget = {
      type: target.type,
      id: target.id,
      x: Number.isFinite(target.x) ? target.x : window.innerWidth * 0.5,
      y: Number.isFinite(target.y) ? target.y : window.innerHeight * 0.5
    };

    dom.crudContextTitle.textContent = target.type === "quote" ? "Quote actions" : "Task actions";

    if (target.type === "task") {
      const task = state.scheduleItems.find((item) => item.id === target.id);
      const isCompleted = Boolean(task?.completed);
      dom.crudToggleButton.hidden = false;
      dom.crudToggleText.textContent = isCompleted ? "Mark active" : "Mark complete";
    } else {
      dom.crudToggleButton.hidden = true;
    }

    dom.appRoot.classList.add("context-menu-open");
    positionCrudContextMenu(state.contextMenuTarget.x, state.contextMenuTarget.y);
  }

  function positionCrudContextMenu(clientX, clientY) {
    const rootRect = dom.appRoot.getBoundingClientRect();
    const menu = dom.crudContextMenu;

    menu.style.left = "16px";
    menu.style.top = "16px";

    const menuWidth = menu.offsetWidth || 220;
    const menuHeight = menu.offsetHeight || 180;

    const relativeX = clientX - rootRect.left;
    const relativeY = clientY - rootRect.top;

    const margin = 12;
    const maxX = Math.max(margin, rootRect.width - menuWidth - margin);
    const maxY = Math.max(margin, rootRect.height - menuHeight - margin);

    const nextX = clampNumber(relativeX - 22, margin, maxX);
    const nextY = clampNumber(relativeY - 16, margin, maxY);

    menu.style.left = `${nextX}px`;
    menu.style.top = `${nextY}px`;
  }

  function closeCrudContextMenu() {
    state.contextMenuTarget = null;
    dom.appRoot.classList.remove("context-menu-open");
  }

  async function onCrudContextAction(action) {
    const target = state.contextMenuTarget;
    if (!target) {
      return;
    }

    closeCrudContextMenu();

    if (target.type === "task") {
      if (action === "edit") {
        openTaskSheet(target.id);
        return;
      }

      if (action === "toggle") {
        state.scheduleItems = state.scheduleItems.map((item) => {
          if (item.id !== target.id) {
            return item;
          }
          return {
            ...item,
            completed: !item.completed
          };
        });
        saveScheduleItems();
        renderSchedule();
        renderProgress();
        return;
      }

      if (action === "delete") {
        await removeTask(target.id);
      }
      return;
    }

    if (target.type === "quote") {
      if (action === "edit") {
        openQuoteSheet(target.id);
        return;
      }

      if (action === "delete") {
        await removeQuote(target.id);
      }
    }
  }

  function openBotHistorySheet() {
    if (state.currentView !== "bot") {
      return;
    }

    renderBotHistoryList();
    dom.appRoot.classList.add("bot-history-open");
    dom.botHistorySheet.hidden = false;
  }

  function closeBotHistorySheet() {
    dom.appRoot.classList.remove("bot-history-open");
    dom.botHistorySheet.hidden = true;
  }

  function renderBotHistoryList() {
    if (!dom.botHistoryList) {
      return;
    }

    if (!state.botHistory.length) {
      dom.botHistoryList.innerHTML = `
        <li class="bot-history-empty">No previous chats yet.</li>
      `;
      return;
    }

    dom.botHistoryList.innerHTML = state.botHistory
      .map((session) => {
        const preview = sanitizeText(session.preview) || "Previous chat";
        const when = formatDateTime(session.updatedAt || session.createdAt);
        return `
          <li class="bot-history-item">
            <button type="button" class="bot-history-load" data-session-id="${escapeHtml(session.id)}">
              <strong>${escapeHtml(preview)}</strong>
              <span>${escapeHtml(when)}</span>
            </button>
          </li>
        `;
      })
      .join("");
  }

  function onBotHistoryListClick(event) {
    const button = event.target.closest("button[data-session-id]");
    if (!button) {
      return;
    }

    const sessionId = button.dataset.sessionId;
    if (!sessionId) {
      return;
    }

    const session = state.botHistory.find((item) => item.id === sessionId);
    if (!session || !Array.isArray(session.messages)) {
      return;
    }

    state.botMessages = session.messages.map((message, index) => ({
      id: typeof message.id === "string" ? message.id : `bot-history-${sessionId}-${index}`,
      role: message.role === "user" ? "user" : "assistant",
      text: sanitizeText(message.text),
      source: sanitizeText(message.source),
      pending: false,
      createdAt: typeof message.createdAt === "string" ? message.createdAt : new Date().toISOString()
    })).filter((message) => message.text);

    saveBotMessages();
    renderBotMessages();
    closeBotHistorySheet();
  }

  function archiveCurrentBotSession() {
    if (!Array.isArray(state.botMessages) || !state.botMessages.length) {
      return;
    }

    const cleanMessages = state.botMessages
      .filter((message) => message && (message.role === "user" || message.role === "assistant") && sanitizeText(message.text))
      .map((message, index) => ({
        id: typeof message.id === "string" ? message.id : `bot-archived-${index}`,
        role: message.role === "user" ? "user" : "assistant",
        text: sanitizeText(message.text),
        source: sanitizeText(message.source),
        pending: false,
        createdAt: typeof message.createdAt === "string" ? message.createdAt : new Date().toISOString()
      }));

    if (!cleanMessages.length) {
      return;
    }

    const firstUser = cleanMessages.find((message) => message.role === "user");
    const previewText = firstUser ? firstUser.text : cleanMessages[0].text;
    const preview = previewText.slice(0, 68);

    const nowIso = new Date().toISOString();
    state.botHistory.unshift({
      id: `session-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      preview,
      createdAt: cleanMessages[0].createdAt || nowIso,
      updatedAt: nowIso,
      messages: cleanMessages
    });

    state.botHistory = state.botHistory.slice(0, 60);
    saveBotHistory();
    renderBotHistoryList();
  }

  function startNewBotChatSession() {
    archiveCurrentBotSession();
    state.botMessages = [];
    saveBotMessages();
    renderBotMessages();
  }

  function findQuoteCardById(id) {
    const cards = dom.quoteList.querySelectorAll(".quote-item[data-quote-id]");
    for (const card of cards) {
      if (card.dataset.quoteId === id) {
        return card;
      }
    }
    return null;
  }

  function renderBotMessages() {
    if (!state.botMessages.length) {
      dom.botMessageList.innerHTML = `
        <li class="bot-empty">
          <p>Start a new chat with Pikachu.</p>
        </li>
      `;
      return;
    }

    dom.botMessageList.innerHTML = state.botMessages
      .map((message) => {
        const roleClass = message.role === "user" ? "user" : "assistant";
        const safeText = escapeHtml(message.text).replace(/\n/g, "<br>");

        return `
          <li class="bot-message ${roleClass} ${message.pending ? "pending" : ""}">
            <div class="bot-bubble">
              <p>${safeText}</p>
            </div>
          </li>
        `;
      })
      .join("");

    dom.botMessageList.scrollTop = dom.botMessageList.scrollHeight;
  }

  function onBotPromptKeyDown(event) {
    if (event.isComposing) {
      return;
    }
    if (event.key !== "Enter" || event.shiftKey) {
      return;
    }
    event.preventDefault();
    dom.botComposerForm.requestSubmit();
  }

  function autoResizeBotPrompt() {
    dom.botPromptInput.style.height = "auto";
    const maxHeight = 180;
    const nextHeight = Math.min(dom.botPromptInput.scrollHeight, maxHeight);
    dom.botPromptInput.style.height = `${Math.max(54, nextHeight)}px`;
  }

  function applyBotSettingsToUI() {
    dom.botProvider.value = state.botSettings.provider;
    dom.botModel.value = state.botSettings.model;
    dom.botEndpoint.value = state.botSettings.endpoint;
    dom.botApiKey.value = state.botSettings.apiKey;
    dom.botApiKey.required = state.botSettings.provider === "huggingface";
    dom.botApiKey.placeholder = state.botSettings.provider === "huggingface" ? "hf_xxx..." : "Optional for Ollama";

    const hint =
      state.botSettings.provider === "huggingface"
        ? "Use a Hugging Face token with an open-source model like meta-llama/Llama-3.2-3B-Instruct."
        : "For Android emulator, run Ollama on your PC and keep endpoint as http://10.0.2.2:11434/api/chat.";
    dom.botProviderHint.textContent = hint;
  }

  function onBotProviderChange() {
    const nextProvider = dom.botProvider.value === "huggingface" ? "huggingface" : "ollama";
    const previousProvider = state.botSettings.provider;
    const previousDefaults = getDefaultBotSettingsForProvider(previousProvider);
    const nextDefaults = getDefaultBotSettingsForProvider(nextProvider);

    const currentModel = sanitizeText(dom.botModel.value);
    const currentEndpoint = sanitizeText(dom.botEndpoint.value);

    if (!currentModel || currentModel === previousDefaults.model) {
      dom.botModel.value = nextDefaults.model;
    }
    if (!currentEndpoint || currentEndpoint === previousDefaults.endpoint) {
      dom.botEndpoint.value = nextDefaults.endpoint;
    }

    dom.botApiKey.required = nextProvider === "huggingface";
    dom.botApiKey.placeholder = nextProvider === "huggingface" ? "hf_xxx..." : "Optional for Ollama";
    const hint =
      nextProvider === "huggingface"
        ? "Use a Hugging Face token with an open-source model like meta-llama/Llama-3.2-3B-Instruct."
        : "For Android emulator, run Ollama on your PC and keep endpoint as http://10.0.2.2:11434/api/chat.";
    dom.botProviderHint.textContent = hint;
  }

  function onBotSettingsSubmit(event) {
    event.preventDefault();

    const provider = dom.botProvider.value === "huggingface" ? "huggingface" : "ollama";
    const model = sanitizeText(dom.botModel.value);
    const endpoint = sanitizeText(dom.botEndpoint.value);
    const apiKey = sanitizeText(dom.botApiKey.value);

    if (!model) {
      setBotSettingsFeedback("Model is required.", "error");
      return;
    }

    if (!endpoint) {
      setBotSettingsFeedback("Endpoint URL is required.", "error");
      return;
    }

    try {
      // Validate URL format early to avoid runtime fetch errors.
      new URL(endpoint);
    } catch {
      setBotSettingsFeedback("Please enter a valid endpoint URL.", "error");
      return;
    }

    if (provider === "huggingface" && !apiKey) {
      setBotSettingsFeedback("Hugging Face provider requires an API key.", "error");
      return;
    }

    state.botSettings = {
      ...state.botSettings,
      provider,
      model,
      endpoint,
      apiKey
    };

    saveBotSettings();
    applyBotSettingsToUI();
    setBotSettingsFeedback("Bot settings saved.", "success");
  }

  function onBotResetSettings() {
    const ok = window.confirm("Reset bot settings to defaults?");
    if (!ok) {
      return;
    }

    state.botSettings = { ...DEFAULT_BOT_SETTINGS };
    saveBotSettings();
    applyBotSettingsToUI();
    setBotSettingsFeedback("Bot settings reset.", "success");
  }

    async function onBotClearChat() {
    if (!state.botMessages.length) {
      return;
    }

    const ok = await showConfirmDialog({
      title: "Clear chat history?",
      message: "All chat messages will vanish from Pikachu.",
      confirmLabel: "Clear"
    });

    if (!ok) {
      return;
    }

    const messageNodes = dom.botMessageList.querySelectorAll(".bot-message");
    for (const node of messageNodes) {
      node.classList.add("is-vanishing");
    }

    if (messageNodes.length) {
      await Promise.all(Array.from(messageNodes).map((node) => runDeleteVanishAnimation(node)));
    }

    state.botMessages = [];
    saveBotMessages();
    renderBotMessages();
    renderBotHistoryList();
    clearBotSettingsFeedback();
  }


  function clearBotSettingsFeedback() {
    dom.botSettingsFeedback.textContent = "";
    dom.botSettingsFeedback.className = "profile-feedback";
  }

  function setBotSettingsFeedback(message, type) {
    dom.botSettingsFeedback.textContent = message;
    dom.botSettingsFeedback.className = `profile-feedback ${type}`;
  }

  function setBotSendingState(isSending) {
    state.botIsSending = isSending;
    dom.botPromptInput.disabled = isSending;
    dom.botSendButton.disabled = isSending;
    dom.botSendButton.innerHTML = isSending
      ? '<span class="material-symbols-rounded">hourglass_top</span>'
      : '<span class="material-symbols-rounded">send</span>';
    dom.botSendButton.setAttribute("aria-label", isSending ? "Sending" : "Send message");
  }

  function onBotStopRequest(silent = true) {
    if (!state.botIsSending && !state.botAbortController) {
      return;
    }

    if (state.botAbortController) {
      state.botAbortController.abort();
      state.botAbortController = null;
    }

    state.botMessages = state.botMessages.filter((message) => !message.pending);
    saveBotMessages();
    renderBotMessages();
    renderBotHistoryList();
    setBotSendingState(false);

    if (!silent) {
      setBotSettingsFeedback("Bot request stopped.", "success");
    }
  }

  async function onBotComposerSubmit(event) {
    event.preventDefault();

    if (state.botIsSending) {
      return;
    }

    const prompt = sanitizeText(dom.botPromptInput.value);
    if (!prompt) {
      return;
    }

    clearBotSettingsFeedback();
    updateBotMemoryFromPrompt(prompt);
    saveBotMemory();

    state.botMessages.push(createBotMessage("user", prompt, "local"));
    state.botMessages.push(createBotMessage("assistant", "Thinking...", "", true));
    saveBotMessages();
    renderBotMessages();
    renderBotHistoryList();

    dom.botPromptInput.value = "";
    autoResizeBotPrompt();
    setBotSendingState(true);

    const requestToken = ++state.botRequestToken;
    state.botAbortController = new AbortController();

    try {
      const conversation = buildBotConversationMessages();
      const response = await requestBotResponse(conversation, state.botAbortController.signal);

      if (requestToken !== state.botRequestToken) {
        return;
      }

      state.botMessages = state.botMessages.map((message) => {
        if (!message.pending) {
          return message;
        }
        return {
          ...message,
          text: response.text,
          source: response.source,
          pending: false,
          createdAt: new Date().toISOString()
        };
      });

      saveBotMessages();
      renderBotMessages();
    renderBotHistoryList();
    } catch (error) {
      const isAbort = error && error.name === "AbortError";

      if (isAbort) {
        state.botMessages = state.botMessages.filter((message) => !message.pending);
        saveBotMessages();
        renderBotMessages();
    renderBotHistoryList();
      } else {
        const fallbackReply = buildOfflineBotReply(prompt, error instanceof Error ? error.message : "Unknown error");
        state.botMessages = state.botMessages.map((message) => {
          if (!message.pending) {
            return message;
          }
          return {
            ...message,
            text: fallbackReply,
            source: "Offline fallback",
            pending: false,
            createdAt: new Date().toISOString()
          };
        });
        saveBotMessages();
        renderBotMessages();
    renderBotHistoryList();
        setBotSettingsFeedback("Model request failed. Using offline fallback response.", "error");
      }
    } finally {
      if (requestToken === state.botRequestToken) {
        state.botAbortController = null;
        setBotSendingState(false);
      }
    }
  }

  async function requestBotResponse(conversationMessages, abortSignal) {
    if (state.botSettings.provider === "huggingface") {
      return queryHuggingFaceChat(conversationMessages, abortSignal);
    }
    return queryOllamaChat(conversationMessages, abortSignal);
  }

  async function queryOllamaChat(messages, abortSignal) {
    const endpoint = sanitizeText(state.botSettings.endpoint) || OLLAMA_DEFAULT_ENDPOINT;
    const model = sanitizeText(state.botSettings.model) || DEFAULT_BOT_SETTINGS.model;
    const apiKey = sanitizeText(state.botSettings.apiKey);

    const headers = {
      "Content-Type": "application/json"
    };
    if (apiKey) {
      headers.Authorization = `Bearer ${apiKey}`;
    }

    const response = await fetchWithTimeout(endpoint, {
      method: "POST",
      headers,
      body: JSON.stringify({
        model,
        stream: false,
        messages,
        options: {
          temperature: 0.4
        }
      }),
      signal: abortSignal
    });

    if (!response.ok) {
      const details = await response.text();
      throw new Error(`Ollama request failed (${response.status}). ${details.slice(0, 180)}`);
    }

    const data = await response.json();
    const text = sanitizeText(data?.message?.content || data?.response || "");

    if (!text) {
      throw new Error("Ollama returned an empty response.");
    }

    return {
      text,
      source: `${model} via Ollama`
    };
  }

  async function queryHuggingFaceChat(messages, abortSignal) {
    const endpoint = sanitizeText(state.botSettings.endpoint) || HUGGINGFACE_CHAT_ENDPOINT;
    const model = sanitizeText(state.botSettings.model) || "meta-llama/Llama-3.2-3B-Instruct";
    const apiKey = sanitizeText(state.botSettings.apiKey);

    if (!apiKey) {
      throw new Error("Hugging Face API key is missing.");
    }

    const response = await fetchWithTimeout(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages,
        max_tokens: 500,
        temperature: 0.4
      }),
      signal: abortSignal
    });

    if (!response.ok) {
      const details = await response.text();
      throw new Error(`Hugging Face request failed (${response.status}). ${details.slice(0, 180)}`);
    }

    const data = await response.json();
    const text = sanitizeText(data?.choices?.[0]?.message?.content || "");

    if (!text) {
      throw new Error("Hugging Face returned an empty response.");
    }

    return {
      text,
      source: `${model} via Hugging Face`
    };
  }

  async function fetchWithTimeout(input, init = {}) {
    const timeoutMs = BOT_REQUEST_TIMEOUT_MS;
    if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {
      return fetch(input, init);
    }

    const timeoutController = new AbortController();
    const timeoutId = window.setTimeout(() => {
      timeoutController.abort();
    }, timeoutMs);

    const externalSignal = init.signal;
    const signal = mergeAbortSignals(externalSignal, timeoutController.signal);

    try {
      return await fetch(input, {
        ...init,
        signal
      });
    } catch (error) {
      const isTimeout = timeoutController.signal.aborted && (!externalSignal || !externalSignal.aborted);
      if (isTimeout) {
        throw new Error(`Request timed out after ${timeoutMs / 1000}s.`);
      }
      throw error;
    } finally {
      window.clearTimeout(timeoutId);
    }
  }

  function mergeAbortSignals(primary, secondary) {
    if (!primary) {
      return secondary;
    }
    if (!secondary) {
      return primary;
    }
    if (primary.aborted) {
      return primary;
    }
    if (secondary.aborted) {
      return secondary;
    }

    const controller = new AbortController();
    const abort = () => {
      if (!controller.signal.aborted) {
        controller.abort();
      }
    };

    primary.addEventListener("abort", abort, { once: true });
    secondary.addEventListener("abort", abort, { once: true });
    return controller.signal;
  }

  function buildBotConversationMessages() {
    const history = state.botMessages
      .filter((message) => !message.pending && (message.role === "user" || message.role === "assistant"))
      .slice(-BOT_MAX_CONTEXT_MESSAGES)
      .map((message) => ({
        role: message.role,
        content: message.text
      }));

    const systemPrompt = `${state.botSettings.systemPrompt}\n\n${buildTaskContextForBot()}`;

    return [
      {
        role: "system",
        content: systemPrompt
      },
      ...history
    ];
  }

  function buildTaskContextForBot() {
    const total = state.scheduleItems.length;
    const completed = state.scheduleItems.filter((item) => item.completed).length;
    const active = Math.max(total - completed, 0);

    const profileFields = [
      `Name: ${sanitizeText(state.profile.fullName) || "User"}`,
      sanitizeText(state.profile.email) ? `Email: ${sanitizeText(state.profile.email)}` : "",
      sanitizeText(state.profile.phone) ? `Phone: ${sanitizeText(state.profile.phone)}` : "",
      sanitizeText(state.profile.city) ? `City: ${sanitizeText(state.profile.city)}` : "",
      sanitizeText(state.profile.bio) ? `Bio: ${sanitizeText(state.profile.bio)}` : ""
    ].filter(Boolean);

    const taskLines = state.scheduleItems
      .map((item) => `${item.time} | ${item.title} | ${item.completed ? "completed" : "active"}`)
      .slice(0, 12);

    const quoteLines = [...state.quotes]
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .slice(0, 3)
      .map((quote) => `"${quote.text}"${quote.author ? ` - ${quote.author}` : ""}`);

    const topInterests = getTopBotMemoryTerms(8);

    return [
      "User Profile:",
      ...profileFields,
      "",
      `Schedule Summary: ${total} tasks total, ${completed} completed, ${active} active.`,
      ...taskLines,
      "",
      "Recent Quotes:",
      ...(quoteLines.length ? quoteLines : ["No quotes saved yet."]),
      "",
      `Adaptive Memory: ${state.botMemory.interactions} interactions tracked.`,
      topInterests.length ? `Top interests: ${topInterests.join(", ")}` : "Top interests: none yet"
    ].join("\n");
  }

  function buildOfflineBotReply(userPrompt, errorMessage) {
    const total = state.scheduleItems.length;
    const completed = state.scheduleItems.filter((item) => item.completed).length;
    const active = Math.max(total - completed, 0);

    return [
      `I could not reach the configured model endpoint (${errorMessage}).`,
      "Offline planner mode:",
      `- You currently have ${total} tasks (${completed} completed, ${active} active).`,
      "- Try one focused 45-minute block, then 10-minute break.",
      "- Prioritize the single highest-impact task first.",
      `Your message was: "${userPrompt}"`
    ].join("\n");
  }

  function getTopBotMemoryTerms(limit = 6) {
    const terms = state.botMemory?.terms || {};
    return Object.entries(terms)
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([term]) => term);
  }

  function updateBotMemoryFromPrompt(prompt) {
    const text = sanitizeText(prompt).toLowerCase();
    if (!text) {
      return;
    }

    const stopWords = new Set([
      "the", "and", "for", "with", "that", "this", "from", "have", "your", "you", "are", "was", "were", "will", "would", "could", "should", "please", "about", "into", "today", "tomorrow", "task", "tasks"
    ]);

    const words = text.match(/[a-z0-9]{3,}/g) || [];

    state.botMemory.interactions += 1;
    if (!state.botMemory.terms || typeof state.botMemory.terms !== "object") {
      state.botMemory.terms = {};
    }

    for (const word of words) {
      if (stopWords.has(word)) {
        continue;
      }
      state.botMemory.terms[word] = (state.botMemory.terms[word] || 0) + 1;
    }

    const trimmed = Object.entries(state.botMemory.terms)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 80);
    state.botMemory.terms = Object.fromEntries(trimmed);
  }
  function createBotMessage(role, text, source, pending = false) {
    return {
      id: `bot-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      role,
      text,
      source,
      pending,
      createdAt: new Date().toISOString()
    };
  }

  function getDefaultBotSettingsForProvider(provider) {
    if (provider === "huggingface") {
      return {
        provider: "huggingface",
        model: "meta-llama/Llama-3.2-3B-Instruct",
        endpoint: HUGGINGFACE_CHAT_ENDPOINT,
        apiKey: BOT_FIXED_FREE_API_KEY,
        systemPrompt: DEFAULT_BOT_SETTINGS.systemPrompt
      };
    }

    return {
      provider: "huggingface",
      model: DEFAULT_BOT_SETTINGS.model,
      endpoint: HUGGINGFACE_CHAT_ENDPOINT,
      apiKey: BOT_FIXED_FREE_API_KEY,
      systemPrompt: DEFAULT_BOT_SETTINGS.systemPrompt
    };
  }
    function applyProfileToUI() {
    const fullName = sanitizeText(state.profile.fullName) || "User";
    const subtitle =
      sanitizeText(state.profile.email) ||
      sanitizeText(state.profile.phone) ||
      "Personal Planner";

    dom.drawerProfileAvatar.textContent = fullName.charAt(0).toUpperCase();
    dom.drawerProfileName.textContent = fullName;
    dom.drawerProfileMeta.textContent = subtitle;

    populateProfileForm();
    updateTodayHeaderRealtime();
  }

  function populateProfileForm() {
    dom.profileName.value = state.profile.fullName;
    dom.profileEmail.value = state.profile.email;
    dom.profilePhone.value = state.profile.phone;
    dom.profileBirthDate.value = state.profile.birthDate;
    dom.profileCity.value = state.profile.city;
    dom.profileAddress.value = state.profile.address;
    dom.profileBio.value = state.profile.bio;
    dom.profileLockEnabled.checked = Boolean(state.profile.lockEnabled);
    dom.profilePassword.value = "";
    dom.profilePasswordConfirm.value = "";
  }

  function applyPasswordFeatureState() {
    if (PASSWORD_FEATURE_ENABLED) {
      return;
    }

    dom.profileLockEnabled.checked = false;
    dom.profileLockEnabled.disabled = true;
    dom.profilePassword.disabled = true;
    dom.profilePasswordConfirm.disabled = true;

    if (dom.profileLockRow) {
      dom.profileLockRow.hidden = true;
    }
    if (dom.profilePasswordLabel) {
      dom.profilePasswordLabel.hidden = true;
    }
    if (dom.profilePasswordConfirmLabel) {
      dom.profilePasswordConfirmLabel.hidden = true;
    }

    dom.profilePassword.hidden = true;
    dom.profilePasswordConfirm.hidden = true;

    if (dom.profileHint) {
      dom.profileHint.textContent = "Password feature is temporarily disabled.";
    }

    state.profile.lockEnabled = false;
    state.profile.passwordHash = "";
    saveProfile();
  }

  function openProfileSheet() {
    closeTaskSheet();
    closeQuoteSheet();
    closeDrawer();
    clearProfileFeedback();
    populateProfileForm();
    dom.appRoot.classList.add("profile-open");
    window.requestAnimationFrame(() => {
      dom.profileName.focus();
    });
  }

  function closeProfileSheet() {
    dom.appRoot.classList.remove("profile-open");
  }

  function onProfileSubmit(event) {
    event.preventDefault();

    const fullName = sanitizeText(dom.profileName.value);
    const email = sanitizeText(dom.profileEmail.value).toLowerCase();
    const phone = sanitizeText(dom.profilePhone.value);
    const birthDate = sanitizeText(dom.profileBirthDate.value);
    const city = sanitizeText(dom.profileCity.value);
    const address = sanitizeText(dom.profileAddress.value);
    const bio = sanitizeText(dom.profileBio.value);

    if (fullName.length < 2) {
      setProfileFeedback("Please enter your full name (at least 2 characters).", "error");
      return;
    }

    if (email && !EMAIL_PATTERN.test(email)) {
      setProfileFeedback("Please enter a valid email address.", "error");
      return;
    }

    if (phone && !PHONE_PATTERN.test(phone)) {
      setProfileFeedback("Please enter a valid phone number.", "error");
      return;
    }

    state.profile = {
      ...state.profile,
      fullName,
      email,
      phone,
      birthDate,
      city,
      address,
      bio,
      lockEnabled: false,
      passwordHash: ""
    };

    saveProfile();
    applyProfileToUI();
    setProfileFeedback("Profile updated successfully.", "success");

    window.setTimeout(() => {
      closeProfileSheet();
    }, 220);
  }

  function onProfileReset() {
    const ok = window.confirm("Reset all profile details?");
    if (!ok) {
      return;
    }

    state.profile = { ...DEFAULT_PROFILE };
    saveProfile();
    applyProfileToUI();
    setProfileFeedback("Profile reset complete.", "success");
  }

  function clearProfileFeedback() {
    dom.profileFeedback.textContent = "";
    dom.profileFeedback.className = "profile-feedback";
  }

  function setProfileFeedback(message, type) {
    dom.profileFeedback.textContent = message;
    dom.profileFeedback.className = `profile-feedback ${type}`;
  }


  function onThemeToggleClick() {
    const nextTheme = state.theme === "light" ? "dark" : "light";
    applyTheme(nextTheme, true);
  }

  function loadThemePreference() {
    const saved = sanitizeText(safeStorageGet(THEME_STORAGE_KEY)).toLowerCase();
    if (saved === "dark" || saved === "light") {
      return saved;
    }

    if (window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches) {
      return "light";
    }

    return "dark";
  }

  function applyTheme(theme, persist = true) {
    const normalized = theme === "light" ? "light" : "dark";
    state.theme = normalized;
    document.body.dataset.theme = normalized;
    dom.appRoot.dataset.theme = normalized;

    if (dom.themeToggleIcon) {
      dom.themeToggleIcon.textContent = normalized === "dark" ? "light_mode" : "dark_mode";
    }

    if (dom.themeToggleButton) {
      dom.themeToggleButton.setAttribute(
        "aria-label",
        normalized === "dark" ? "Switch to light mode" : "Switch to dark mode"
      );
    }

    if (persist) {
      safeStorageSet(THEME_STORAGE_KEY, normalized);
    }
  }
  function applyPerformanceMode() {
    const memory = Number(navigator.deviceMemory || 0);
    const saveData = Boolean(navigator.connection && navigator.connection.saveData);
    const reducedMotion = Boolean(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches);
    const lowMemoryDevice = memory > 0 && memory <= 4;
    const userAgent = String(navigator.userAgent || "");
    const isAndroid = /android/i.test(userAgent);
    const isWebView = /\bwv\b/i.test(userAgent) || /version\/\d+\.\d+ chrome\//i.test(userAgent);
    const enableLiteMode = lowMemoryDevice || saveData || reducedMotion || isAndroid || isWebView;

    document.body.classList.toggle("perf-lite", enableLiteMode);
  }

  function startRealtimeClock() {
    updateTodayHeaderRealtime();

    if (state.clockTimer) {
      window.clearInterval(state.clockTimer);
    }

    state.clockTimer = window.setInterval(() => {
      updateTodayHeaderRealtime();
    }, 1000);
  }

  function updateTodayHeaderRealtime() {
    const fullName = sanitizeText(state.profile.fullName) || "User";
    const firstName = fullName.split(/\s+/)[0];
    const now = new Date();

    const greeting = getGreetingForHour(now.getHours());
    dom.greetingText.textContent = `${greeting}, ${firstName}`;

    dom.todayDateText.textContent = now.toLocaleDateString(undefined, {
      weekday: "long",
      day: "numeric",
      month: "long",
      year: "numeric"
    });

    dom.todayTimeText.textContent = now.toLocaleTimeString(undefined, {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }

  function getGreetingForHour(hour) {
    if (hour >= 5 && hour < 12) {
      return "Good morning";
    }
    if (hour >= 12 && hour < 17) {
      return "Good afternoon";
    }
    if (hour >= 17 && hour < 22) {
      return "Good evening";
    }
    return "Good night";
  }

  function onUserInteraction() {
    if (state.currentView === "bot") {
      return;
    }

    if (
      dom.appRoot.classList.contains("profile-open") ||
      dom.appRoot.classList.contains("quote-open") ||
      dom.appRoot.classList.contains("task-open") ||
      dom.appRoot.classList.contains("confirm-open") ||
      dom.appRoot.classList.contains("context-menu-open") ||
      dom.appRoot.classList.contains("bot-history-open")
    ) {
      return;
    }

    if (state.botFabHidden) {
      return;
    }

    scheduleBotFabAutoHide();
  }

  function onVisibilityChange() {
    if (document.hidden) {
      clearBotFabAutoHideTimer();
      return;
    }

    if (state.currentView !== "bot") {
      showBotFab(true);
    }
  }

  function clearBotFabAutoHideTimer() {
    if (!state.botFabAutoHideTimer) {
      return;
    }

    window.clearTimeout(state.botFabAutoHideTimer);
    state.botFabAutoHideTimer = 0;
  }

  function scheduleBotFabAutoHide() {
    clearBotFabAutoHideTimer();

    state.botFabAutoHideTimer = window.setTimeout(() => {
      if (state.currentView === "bot") {
        return;
      }

      state.botFabHidden = true;
      dom.appRoot.classList.add("bot-fab-hidden");
    }, BOT_FAB_AUTO_HIDE_MS);
  }

  function showBotFab(shouldScheduleAutoHide = false) {
    clearBotFabAutoHideTimer();
    state.botFabHidden = false;
    dom.appRoot.classList.remove("bot-fab-hidden");

    if (shouldScheduleAutoHide && state.currentView !== "bot") {
      scheduleBotFabAutoHide();
    }
  }

  function onBotRevealButtonClick() {
    showBotFab(true);
  }

  function showConfirmDialog(options = {}) {
    const title = sanitizeText(options.title) || "Confirm action";
    const message = sanitizeText(options.message) || "This action cannot be undone.";
    const confirmLabel = sanitizeText(options.confirmLabel) || "Delete";

    if (state.confirmResolver) {
      resolveConfirmDialog(false);
    }

    closeDrawer();

    dom.confirmTitle.textContent = title;
    dom.confirmMessage.textContent = message;
    dom.confirmAcceptButton.textContent = confirmLabel;
    dom.appRoot.classList.add("confirm-open");

    return new Promise((resolve) => {
      state.confirmResolver = resolve;
    });
  }

  function resolveConfirmDialog(accepted) {
    dom.appRoot.classList.remove("confirm-open");

    if (!state.confirmResolver) {
      return;
    }

    const resolver = state.confirmResolver;
    state.confirmResolver = null;
    resolver(Boolean(accepted));
  }

  function runDeleteVanishAnimation(element) {
    if (!element) {
      return Promise.resolve();
    }

    return new Promise((resolve) => {
      let settled = false;

      const finish = () => {
        if (settled) {
          return;
        }
        settled = true;
        element.removeEventListener("animationend", onAnimationEnd);
        resolve();
      };

      const onAnimationEnd = (event) => {
        if (event.target !== element) {
          return;
        }
        finish();
      };

      element.addEventListener("animationend", onAnimationEnd);
      element.classList.add("is-vanishing");
      window.setTimeout(finish, 420);
    });
  }
  function onWindowResize() {
    if (state.resizeTicking) {
      return;
    }

    state.resizeTicking = true;
    window.requestAnimationFrame(() => {
      applyAdaptiveLayout(false);
      scheduleQuotesLauncherRender();
      state.resizeTicking = false;
    });
  }

  function applyAdaptiveLayout(initialLoad) {
    const previousSize = state.size;
    const currentSize = detectSize(window.innerWidth);

    state.size = currentSize;
    dom.appRoot.dataset.size = currentSize;

    if (currentSize === "expanded") {
      dom.appRoot.classList.add("drawer-open");
      return;
    }

    if (currentSize === "medium") {
      if (initialLoad || previousSize === "expanded") {
        dom.appRoot.classList.add("drawer-open");
      }
      return;
    }

    dom.appRoot.classList.remove("drawer-open");
  }

  function detectSize(width) {
    if (width >= BREAKPOINTS.expanded) {
      return "expanded";
    }
    if (width >= BREAKPOINTS.medium) {
      return "medium";
    }
    return "compact";
  }

  function toggleDrawer() {
    if (state.size === "expanded" || dom.appRoot.classList.contains("profile-open") || dom.appRoot.classList.contains("quote-open") || dom.appRoot.classList.contains("task-open") || dom.appRoot.classList.contains("confirm-open") || dom.appRoot.classList.contains("context-menu-open") || dom.appRoot.classList.contains("bot-history-open")) {
      return;
    }

    if (dom.appRoot.classList.contains("drawer-open")) {
      closeDrawer();
      return;
    }
    openDrawer();
  }

  function openDrawer() {
    if (state.size === "expanded" || dom.appRoot.classList.contains("profile-open") || dom.appRoot.classList.contains("quote-open") || dom.appRoot.classList.contains("task-open") || dom.appRoot.classList.contains("confirm-open") || dom.appRoot.classList.contains("context-menu-open") || dom.appRoot.classList.contains("bot-history-open")) {
      return;
    }
    dom.appRoot.classList.add("drawer-open");
  }

  function closeDrawer() {
    if (state.size === "expanded") {
      return;
    }
    dom.appRoot.classList.remove("drawer-open");
  }

  function onTouchStart(event) {
    if (state.size === "expanded" || dom.appRoot.classList.contains("profile-open") || dom.appRoot.classList.contains("quote-open") || dom.appRoot.classList.contains("task-open") || dom.appRoot.classList.contains("confirm-open") || dom.appRoot.classList.contains("context-menu-open") || dom.appRoot.classList.contains("bot-history-open") || !event.touches.length) {
      return;
    }

    const touch = event.touches[0];
    state.touchStartX = touch.clientX;
    state.touchStartY = touch.clientY;
    state.touchLastX = touch.clientX;
    state.touchLastY = touch.clientY;
    state.touchActive = true;
  }

  function onTouchMove(event) {
    if (!state.touchActive || !event.touches.length) {
      return;
    }

    const touch = event.touches[0];
    state.touchLastX = touch.clientX;
    state.touchLastY = touch.clientY;
  }

  function onTouchEnd() {
    if (!state.touchActive || state.size === "expanded") {
      resetTouchState();
      return;
    }

    const deltaX = state.touchLastX - state.touchStartX;
    const deltaY = Math.abs(state.touchLastY - state.touchStartY);
    const isMostlyHorizontal = Math.abs(deltaX) > deltaY;
    const isDrawerOpen = dom.appRoot.classList.contains("drawer-open");
    const openedFromEdge = state.touchStartX <= 24;

    if (isMostlyHorizontal && !isDrawerOpen && openedFromEdge && deltaX >= 60) {
      openDrawer();
    }

    if (isMostlyHorizontal && isDrawerOpen && deltaX <= -60) {
      closeDrawer();
    }

    resetTouchState();
  }

  function resetTouchState() {
    state.touchStartX = 0;
    state.touchStartY = 0;
    state.touchLastX = 0;
    state.touchLastY = 0;
    state.touchActive = false;
  }

  function loadScheduleItems() {
    const fallback = DEFAULT_SCHEDULE_ITEMS.map((item) => ({ ...item }));
    const raw = safeStorageGet(TASK_STORAGE_KEY);

    if (!raw) {
      return fallback;
    }

    try {
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed) || !parsed.length) {
        return fallback;
      }

      return parsed
        .filter((item) => item && typeof item === "object")
        .map((item, index) => ({
          id: typeof item.id === "string" ? item.id : `task-${index + 1}`,
          time: typeof item.time === "string" ? item.time : "00:00 - 00:00",
          title: typeof item.title === "string" ? item.title : "Untitled task",
          tag: typeof item.tag === "string" && sanitizeText(item.tag) ? sanitizeText(item.tag) : getTaskTagLabel(item.tagClass),
          tagClass: normalizeTagClass(item.tagClass),
          completed: Boolean(item.completed)
        }));
    } catch {
      return fallback;
    }
  }

  function saveScheduleItems() {
    safeStorageSet(TASK_STORAGE_KEY, JSON.stringify(state.scheduleItems));
  }

  function loadProfile() {
    const raw = safeStorageGet(PROFILE_STORAGE_KEY);
    if (!raw) {
      return { ...DEFAULT_PROFILE };
    }

    try {
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        return { ...DEFAULT_PROFILE };
      }

      return {
        fullName: sanitizeText(parsed.fullName) || DEFAULT_PROFILE.fullName,
        email: sanitizeText(parsed.email).toLowerCase(),
        phone: sanitizeText(parsed.phone),
        birthDate: sanitizeText(parsed.birthDate),
        city: sanitizeText(parsed.city),
        address: sanitizeText(parsed.address),
        bio: sanitizeText(parsed.bio),
        lockEnabled: false,
        passwordHash: ""
      };
    } catch {
      return { ...DEFAULT_PROFILE };
    }
  }

  function saveProfile() {
    safeStorageSet(PROFILE_STORAGE_KEY, JSON.stringify(state.profile));
  }

  function loadQuotes() {
    const raw = safeStorageGet(QUOTES_STORAGE_KEY);
    if (!raw) {
      return [];
    }

    try {
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) {
        return [];
      }

      return parsed
        .filter((item) => item && typeof item === "object")
        .map((item, index) => ({
          id: typeof item.id === "string" ? item.id : `quote-${index + 1}`,
          text: sanitizeText(item.text),
          author: sanitizeText(item.author),
          createdAt: typeof item.createdAt === "string" ? item.createdAt : new Date().toISOString(),
          updatedAt: typeof item.updatedAt === "string" ? item.updatedAt : new Date().toISOString()
        }))
        .filter((quote) => quote.text);
    } catch {
      return [];
    }
  }

  function saveQuotes() {
    safeStorageSet(QUOTES_STORAGE_KEY, JSON.stringify(state.quotes));
  }

  function loadQuotesLauncher() {
    const raw = safeStorageGet(QUOTES_LAUNCHER_STORAGE_KEY);
    if (!raw) {
      return { ...DEFAULT_QUOTES_LAUNCHER };
    }

    try {
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        return { ...DEFAULT_QUOTES_LAUNCHER };
      }

      return {
        x: Number.isFinite(parsed.x) ? parsed.x : DEFAULT_QUOTES_LAUNCHER.x,
        y: Number.isFinite(parsed.y) ? parsed.y : DEFAULT_QUOTES_LAUNCHER.y,
        size: Number.isFinite(parsed.size) ? parsed.size : DEFAULT_QUOTES_LAUNCHER.size,
        label: sanitizeText(parsed.label) || DEFAULT_QUOTES_LAUNCHER.label
      };
    } catch {
      return { ...DEFAULT_QUOTES_LAUNCHER };
    }
  }

  function saveQuotesLauncher() {
    safeStorageSet(
      QUOTES_LAUNCHER_STORAGE_KEY,
      JSON.stringify({
        x: state.quotesLauncher.x,
        y: state.quotesLauncher.y,
        size: state.quotesLauncher.size,
        label: state.quotesLauncher.label
      })
    );
  }

  function loadBotSettings() {
    // Force simple chat mode: integrated free backend, no user-facing model/provider controls.
    return { ...DEFAULT_BOT_SETTINGS };
  }

  function saveBotSettings() {
    safeStorageSet(BOT_SETTINGS_STORAGE_KEY, JSON.stringify(state.botSettings));
  }
  function loadBotMemory() {
    const raw = safeStorageGet(BOT_MEMORY_STORAGE_KEY);
    if (!raw) {
      return { ...DEFAULT_BOT_MEMORY };
    }

    try {
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") {
        return { ...DEFAULT_BOT_MEMORY };
      }

      return {
        interactions: Number.isFinite(parsed.interactions) ? Math.max(0, parsed.interactions) : 0,
        terms: parsed.terms && typeof parsed.terms === "object" ? parsed.terms : {}
      };
    } catch {
      return { ...DEFAULT_BOT_MEMORY };
    }
  }

  function saveBotMemory() {
    safeStorageSet(BOT_MEMORY_STORAGE_KEY, JSON.stringify(state.botMemory));
  }
  function loadBotMessages() {
    const raw = safeStorageGet(BOT_MESSAGES_STORAGE_KEY);
    if (!raw) {
      return [];
    }

    try {
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) {
        return [];
      }

      return parsed
        .filter((item) => item && typeof item === "object")
        .map((item, index) => ({
          id: typeof item.id === "string" ? item.id : `bot-${index + 1}`,
          role: item.role === "user" ? "user" : "assistant",
          text: sanitizeText(item.text),
          source: sanitizeText(item.source),
          pending: false,
          createdAt: typeof item.createdAt === "string" ? item.createdAt : new Date().toISOString()
        }))
        .filter((message) => message.text);
    } catch {
      return [];
    }
  }

  function saveBotMessages() {
    safeStorageSet(BOT_MESSAGES_STORAGE_KEY, JSON.stringify(state.botMessages));
  }
  function loadBotHistory() {
    const raw = safeStorageGet(BOT_HISTORY_STORAGE_KEY);
    if (!raw) {
      return [];
    }

    try {
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) {
        return [];
      }

      return parsed
        .filter((session) => session && typeof session === "object")
        .map((session, index) => ({
          id: typeof session.id === "string" ? session.id : `session-${index + 1}`,
          preview: sanitizeText(session.preview) || "Previous chat",
          createdAt: typeof session.createdAt === "string" ? session.createdAt : new Date().toISOString(),
          updatedAt: typeof session.updatedAt === "string" ? session.updatedAt : new Date().toISOString(),
          messages: Array.isArray(session.messages)
            ? session.messages
              .filter((message) => message && typeof message === "object")
              .map((message, messageIndex) => ({
                id: typeof message.id === "string" ? message.id : `msg-${messageIndex + 1}`,
                role: message.role === "user" ? "user" : "assistant",
                text: sanitizeText(message.text),
                source: sanitizeText(message.source),
                pending: false,
                createdAt: typeof message.createdAt === "string" ? message.createdAt : new Date().toISOString()
              }))
              .filter((message) => message.text)
            : []
        }))
        .filter((session) => session.messages.length);
    } catch {
      return [];
    }
  }

  function saveBotHistory() {
    safeStorageSet(BOT_HISTORY_STORAGE_KEY, JSON.stringify(state.botHistory));
  }
  function safeStorageGet(key) {
    try {
      return localStorage.getItem(key);
    } catch (error) {
      console.warn(`Storage read failed for key: ${key}`, error);
      return null;
    }
  }

  function safeStorageSet(key, value) {
    try {
      localStorage.setItem(key, value);
      return true;
    } catch (error) {
      console.warn(`Storage write failed for key: ${key}`, error);
      return false;
    }
  }

  function normalizeTagClass(tagClass) {
    const allowed = new Set(["learning", "fitness", "work", "language", "general"]);
    return allowed.has(tagClass) ? tagClass : "learning";
  }

  function getTaskTagLabel(tagClass) {
    return TASK_TAG_OPTIONS[normalizeTagClass(tagClass)] || TASK_TAG_OPTIONS.learning;
  }

    function formatDate(value) {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) {
      return "Unknown date";
    }
    return date.toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  }

  function formatDateTime(value) {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) {
      return "Unknown time";
    }
    return date.toLocaleString(undefined, {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit"
    });
  }

  function sanitizeText(value) {
    if (typeof value !== "string") {
      return "";
    }
    return value.trim();
  }

  function escapeHtml(value) {
    return String(value)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function clampNumber(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }

  function isPrimaryPointer(event) {
    if (event.pointerType === "mouse") {
      return event.button === 0;
    }
    return event.isPrimary !== false;
  }

  init();
})();























































































